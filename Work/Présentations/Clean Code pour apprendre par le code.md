---
ressource:
  - üé• Talk
tags:
  - Brouillon
  - üößwip
  - ü´ßCleanCode
relates:
  - "[[Conf√©rence Clean Code ou Manuel de lecture du code]]"
  - "[[Knowledge Driven Development]]"
  - "[[Clean Code]]"
---
# Mod√®le mental 

-> On a tous des mod√®les mentaux  
-> Conna√Ætre ses mod√®les mentaux permet d'apprendre √† se d√©fait de ses pr√©jug√©s (cf. 5i√®me Discipline de Peter Senge)  
-> Ils influencent l'image que nous nous faisons du monde  
-> Il s'agit des croyances, postulats, hypoth√®ses ou repr√©sentation qu'a une personne sur elle m√™me, les autre et le monde  
-> Un concept, un syst√®me ou une mani√®re de voir le monde qui nous aide √† comprendre comment les choses fonctionnent  
-> Tous les mod√®les sont faux, mais certains sont utiles (George Box,)  
-> Modeling = coding  
  
# Code Legacy

-> Factuel : il existe  
-> C'est le mode d'emplois r√©el du logiciel  
-> C'est l'opportunit√© d'apprendre de nos pr√©d√©cesseurs  
  
# Code legecy
-> Comment l'appr√©hender  : via des [[Code Review]] :  
--> Se poser et lire du code pendant un temps, avec son √©quipe ou seul  
--> Validation de PR/MR  
--> Via du Pair/Mob Programming o√π on a en plus les explications verbales  
  
Code legacy  
-> Comment l'appr√©hender -> Conna√Ætre les codes smells et les sch√©mas de lecture de notre contexte  
  
Clean Code  
-> Permet dans son contexte, de pr√©senter des Normes et standards  
-> permet de guider les √©quipiers √† adopter le mod√®le mental qui convient au contexte  
--> Cela facilite l'apprentissage et l'on-boarding  
--> #CollectiveOwnership  
  
Clean code   
= code maintenable ?  
-> √ßa veut dire quoi "maintenable" ?  
==> Maintenable = quelqu'un d'autre peut se l'approprier et corriger les defect/bugs/incompr√©hention  
= le mieux que l'on puisse faire de notre point de vue aujourd'hui  
  
Clean Code  
-> Comment ? => Nommage  
--> Se poser la question du nom des choses  
-> Ubiquitous language (DDD)  
-> eXtreme Programming : Communication / system metaphor + Coding standards  
- s√©parer d√©velopper  / nommer  
- M√©thode : 3 Steps Models (Feitelson)  
  
Clean Code  
-> Comment ? => Patterns  
-> Les [[Design Patterns]] donnent une grille de lecture des probl√®mes qu'ils r√©solvent  
-> Comment ? => Mod√©liser le m√©tier  
--> Nommer les concepts  
--> R√©fl√©chir √† la Coh√©sion/Couplage des notions m√©tier rencontr√©es  
  
Clean Code  
-> Comment ? => Principes/Tips/Guides  
-> [[Shu Ha Ri]] (Connaitre, Ma√Ætriser, d√©passer)  
-> ne pas √™tre dogmatique car c'est du gatekeeping  
-> on convain mieux sans buzzwords  
-> SOLID, Demeter, KiSS, YAGNI, DRY  
  
Clean Code vs Code Legacy  
Code qui correspond √† notre mod√®le mental => Code qui nous fait plaisir  
vs.  
Code qui ne correspond pas √† notre mod√®le mentatl => Code qui nous fait souffrir  
  
Refactor (posture d'√©crivain) vs. Code review (posture de lecteur et 'apprenant)  
<Sch√©ma que j'arrivera pas √† reproduire>  
Adapter le code pour qu'il corresponde √† notre mod√®le mental  
vs.  
Apprendre depuis le code et faire √©voluer son propre mod√®le mental en cons√©quence  
  
Refactoriser   
= Passerelle entre le Clean Code et le Code legacy  
-> passerelle passe par notre cerveau  
"[[Writing is Thinking]]"  
  
Code Reveiw  
= Passerelle entre le Code Legacy et Clean Brain/Code  
-> passe par notre cerveau  
  
Zone de confort vs Inconnu  
<Sch√©ma>  
Confrt/S√©curit√© vs Peur/Douleur  
Boucle entre les deux  
-> Sortir de la zone de confort vers l'inconnu pour apprendre  
-> Rentrer dans la zone de confort pour se rassurer/ r√©affirmer ce que l'on sait.  
? travailler sur une notion de Zone d'inconfort ?