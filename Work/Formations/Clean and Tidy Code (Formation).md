---
ressource:
  - üéì Formation
titre: "Conception logicielle avanc√©e : Clean & Tidy Code"
‚åõ dur√©e: üóìÔ∏è 2j
üßë‚Äçüè´ format:
  - Pr√©sentiel
üéì p√©dagogie: 30% th√©orique, 70% pratique
üë• Participants: "8"
Inter (HT/pers): 
Intra (HT): 
üìö th√©matiques:
---

# Format

Sur un format pr√©sentiel pour vivre les ateliers qui seront d√©roul√©s.
# Description

Le logiciel d'aujourd'hui r√©pond aux besoin de l'instant, mais ce n'est pas suffisant quand on d√©veloppe un produit de qualit√©. Un bon produit est conforme dans le temps, maintenable √† moindre frais, et permet de d√©velopper de nouvelles fonctionnalit√©s vite et bien.

Le Clean Code est un ensemble de pratiques contribuant √† rendre cela possible, en permettant aux √©quipes de collaborer efficacement en asynchrone et dans le temps et en leur permettant de fluidifier les interactions entre les humains et le code.

Cette formation vous propose de vous approprier un ensemble de principes, de pratiques et de techniques qui am√©lioreront votre approche du Clean Code, mais aussi des exercices pour comprendre vos pr√©f√©rences en terme de conception logicielle. Cela vous permettra d'appliquer l'ensemble de ces √©l√©ments √† un cadre o√π vous verrez les avantages de mod√©liser judicieusement votre code.

#### Brouillon

> Le Domain Driven Design (DDD) permet de mod√©liser efficacement les besoins m√©tier afin de mieux g√©rer la complexit√© des logiciels. Traditionnellement associ√© √† la Programmation Orient√©e Objet, les patterns tactiques du DDD peuvent toutefois √™tre adapt√©es pour utiliser cette approche avec la Programmation Fonctionnelle.
>
> La Programmation Fonctionnelle est un paradigme qui favorise des techniques comme l'immutabilit√©, les fonctions pures et la composition fonctionnelle pour cr√©er un code plus pr√©visible et maintenable.
>
> Le langage TypeScript est √† cheval entre les approches objets et fonctionnelles, et pr√©sente des particularit√©s qui peuvent rendre difficile l‚Äôadoption du DDD selon l‚Äôun de ces deux paradigmes.
>
> Cette formation vous propose de d√©couvrir des approches adapt√©es sp√©cifiquement √† TypeScript qui int√®grent les avantages de la programmation fonctionnelle avec la structuration de donn√©es sous forme d‚Äôobjets dans un cadre DDD. Vous apprendrez comment impl√©menter des mod√®les m√©tier efficacement et en restant pragmatique sur l‚Äôutilisation du paradigme fonctionnel pour cr√©er des logiciels robustes et maintenables.

>==WIP 
> Le logiciel d'aujourd'hui r√©pond aux besoin de l'instant, mais ce n'est pas suffisant quand on d√©veloppe un produit de qualit√©. Un bon produit est conforme dans le temps, maintenable √† moindre frais, et permet de d√©velopper de nouvelles fonctionnalit√©s vite et bien.
> 
> Le Clean Code est un ensemble de pratiques contribuant √† rendre cela possible, en permettant aux √©quipes de collaborer efficacement en asynchrone et dans le temps et en leur permettant de fluidifier les interactions entre les humains et le code.
> 
> Cette formation vous propose de vous approprier un ensemble de principes et de pratiques qui am√©lioreront votre approche du Clean Code,  des exercices pour comprendre votre pr√©f√©rences en terme de conception logicielle, et d'appliquer l'ensemble de ces √©l√©ments √† un cadre o√π vous verrez les avantages de mod√©liser judicieusement vote code.
>
> Un logiciel est un outil permettant de r√©pondre √† un besoin r√©el
> D√©velopper un logiciel intervient pour r√©pondre √† un besoin m√©tier
> C'est une activit√© d'√©quipe
> Collaborer efficacement 
> "Une bonne conception et une excellence techniuq renforce l'agilit√©"
> 
> A l'issue de cette formation, vous serez en mesure de vous poser des questions permettant de structurer vos logiciels, et vous aurez des √©l√©ments et des arguments de r√©ponses diff√©rentes en fonction des contextes m√©tiers que vous rencontrerez.
> 
> Vous trouverez ces √©l√©ments de compr√©hension au travers de votre compr√©hension du Clean Code, votre approche des Design Patterns et quelques patterns classiques d'architecture logicielle.
> 
> Vous approfondirez des pratiques d'entretiens de votre parc applicatif
> ==


> La p√©rennit√© d‚Äôune base de code repose sur la qualit√© de son √©criture et sur la ma√Ætrise du niveau de sa dette technique. La bonne connaissance des principes SOLID permet de percevoir les non-qualit√©s dans les bases de code existantes et de comprendre les r√®gles du Clean Code. Cette compr√©hension permet de s√©curiser et de garantir le succ√®s de l‚Äô√©tape de refactoring, objet de cette formation.

> Z: 
> L'introduction des m√©thodes agiles a permis de mieux construire des logiciels conformes aux besoins r√©els, et d'am√©liorer le processus de delivery. Le clean code est un ensemble compl√©mentaire de pratiques techniques, permettant d'assurer la p√©rennit√© du logiciel construit. Un code propre est en effet la condition sine qua non d'un logiciel robuste (co√ªt de maintenance limit√©) et √©volutif (pouvant √™tre adapt√© aux nouveaux besoins).

> O:
> Les artisans du logiciel savent que la qualit√© du code va de pair avec la rapidit√©, la simplicit√© et l'efficacit√© du d√©veloppement. Les pratiques, principes et standards qui d√©finissent cette qualit√© sont rassembl√©es sous le vocable ¬´ Clean Code ¬ª. Ils permettent √† toute √©quipe de cr√©er, de maintenir (ou de r√©tablir) un code de grande qualit√©, et concernent de multiples aspects de la programmation : conventions de style, r√®gles de nommage, crit√®res de qualit√© des fonctions, des classes, des relations entre les classes.

√Ä l'issue de cette formation, vous pourrez mettre en ≈ìuvre les pratiques de base permettant d'obtenir un code de grande qualit√©, test√© et flexible..
# Objectifs

- **Comprendre les principes fondamentaux du Clean Code
	- √ätre capable de d√©finir et d'expliquer les concepts cl√©s et les enjeux du Clean Code
	- Savoir appliquer ces principes dans un cadre de travail simple
	- √ätre capable se positionner et d'argumenter face √† des principes moins consensuels
- **Conna√Ætre et reconna√Ætre des structures courantes dans le code**
	- √ätre capable d'identifier des anti-patterns
	- √ätre capable d'identifier des design patterns
	- Savoir s'appuyer sur des principes avanc√©s de conception logicielle pour structurer son code (principes SOLID, Couplage et Coh√©sion)
- Conna√Ætre et savoir appliquer les techniques d'am√©lioration du code (Tidyings et Refactorings) sur du code un peu complexe

#### Brouillon

> **Comp√©tences cibles**

Mettre en √©vidence les connaissances critiques dans le logiciel
Construire une carte mentale permettant de retrouver ce que l'on cherche dans le logiciel
Ecrire du code pour les humains
Ecrire du code facile √† prendre en main

> **Objectif de la Formation**  
> Ce que le stagiaire devra savoir faire √† la fin de la formation, de mani√®re observable  
> Ce qu‚Äôil devra pouvoir conna√Ætre ou comprendre  
> Utiliser des verbes dont le sujet est ¬´ le stagiaire ¬ª et non le formateur  
> D√©finir les conditions :  
> Situations courantes / situations exceptionnelles  
> √âch√©ances, urgences, ‚Ä¶

_<Ce que les personnes form√©es seront faire √† la fin de la formation>_

- Mettre en √©vidence les connaissances critiques dans le logiciel
- Construire une carte mentale permettant de retrouver ce que l'on cherche dans le logiciel
- Ecrire du code pour les humains
- Ecrire du code facile √† prendre en main

- **Comprendre les principes fondamentaux du Clean Code
	- √ätre capable de d√©finir et d'expliquer les concepts cl√©s et les enjeux du Clean Code
	- Savoir appliquer ces principes dans un cadre de travail simple
	- √ätre capable se positionner et d'argumenter face √† des principes moins consensuels
- **Conna√Ætre et reconna√Ætre des structures courantes dans le code**
	- √ätre capable d'identifier des anti-patterns
	- √ätre capable d'identifier des design patterns
	- Savoir s'appuyer sur des principes avanc√©s de conception logicielle pour structurer son code (principes SOLID, Couplage et Coh√©sion)
- Conna√Ætre et savoir appliquer les techniques d'am√©lioration du code (Tidyings et Refactorings) sur du code un peu complexe

Comprendre / Conna√Ætre / maitreiser

- **Comprendre les principes fondamentaux du Clean Code
	- √ätre capable de d√©finir et d'expliquer les concepts cl√©s et les enjeux du Clean Code
	- Savoir appliquer ces principes dans un cadre de travail simple
	- √ätre capable se positionner et d'argumenter face √† des principes moins consensuels
- **Conna√Ætre et reconna√Ætre des structures courantes dans le code**
	- √ätre capable d'identifier des anti-patterns
	- √ätre capable d'identifier des design patterns
	- Savoir s'appuyer sur des principes avanc√©s de conception logicielle pour structurer son code (principes SOLID, Couplage et Coh√©sion)
- Conna√Ætre et savoir appliquer les techniques d'am√©lioration du code (Tidyings et Refactorings) sur du code un peu complexe

- **Comprendre les principes fondamentaux du Clean Code:** D√©finir et expliquer les concepts cl√©s du Clean Code, tels que la lisibilit√©, la maintenabilit√©, la testabilit√© et la r√©utilisabilit√©.
- **Identifier les mauvaises pratiques courantes:** Reconna√Ætre les anti-patterns courants en programmation qui nuisent √† la qualit√© du code.
  => ==Conna√Ætre une grille de lecture du code pour savoir reconnaitre patterns et anti patterns==
- **Appliquer les principes SOLID:** Ma√Ætriser les principes SOLID (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) pour concevoir des classes et des modules bien structur√©s.
- **R√©diger du code propre et expressif:** Utiliser des noms de variables, de fonctions et de classes significatifs, un formatage coh√©rent et des commentaires pertinents.
- **Ma√Ætriser les techniques de refactoring:** Appliquer des techniques de refactoring pour am√©liorer la structure et la lisibilit√© du code existant sans en modifier le comportement.

>Z:
> - Approfondir les principes de programmation orient√©e objet pour √©crire du code conforme √† l'√©tat de l'art
> - Concr√©tiser et mettre en pratique ces principes avec des exemples simples et frappants
> - Mettre sous contr√¥le la dette technique par le refactoring
> - Apprendre les techniques sp√©cifiques aux applications legacy
> - Acqu√©rir une vision synth√©tique des m√©thodes de conception propre les plus utilis√©es

> IB Formations
> - Comprendre la notion de dette technique et les principes SOLID
> - Conna√Ætre les enjeux de l‚Äô√©criture de tests automatis√©s et le co√ªt de la mise en production de code non test√© automatiquement
> - Ma√Ætriser l‚Äô√©criture de tests automatis√©s, unitaires et tests d‚Äôint√©gration ainsi que les principes et patterns du "clean code" en programmation objet
> - Comprendre le principe du travail √† partir de katas et les pratiques de l‚ÄôeXtreme programming : pair programming, coding dojos
> - Savoir appliquer ces principes et patterns au d√©veloppement de nouveau code (greenfield development) et au code existant (brownfield development)

>O: 
> - Identifier, expliquer et illustrer les principaux √©l√©ments qui forment le ¬´ Clean Code ¬ª
> - Savoir utiliser ces standards sur un projet exemple, ainsi que sur du code existant
> - D√©finir le lien entre la qualit√© du code et la facilit√© d'√©volution des applications

# Programme

_\<Programme grosse maille de la formation ou lien vers le plan de cours>_
_\<Cette section permet √©galement de d√©tailler et travailler les diff√©rents modules de la formation>_

| Horaire | Jour 1                                                                                                  | Jour 2                                                           | Jour 3 ?                           |
| ------- | ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | ---------------------------------- |
| 9h00    | üëã Accueil <br>& Petit d√©jeuner ü•ê                                                                      | üëã Accueil <br>& Petit d√©jeuner ü•ê                               | üëã Accueil <br>& Petit d√©jeuner ü•ê |
| 9h30    | Lancement de la journ√©e<br>"le Clean Code n'existe pas"                                                 | Th√©orie: SOLID & Design Patterns                                 |                                    |
| 10h00   | Atelier : On-boarding avec une matrice de connaissance                                                  | Exercice : RPN                                                   |                                    |
| 10h30   |                                                                                                         | Exercice : RPN                                                   |                                    |
| 11h00   | Clean Code : Th√©orie                                                                                    | Th√©orie: SOLID & Design Patterns                                 |                                    |
| 11h30   | Clean Code : Th√©orie                                                                                    | Exercice : RPN                                                   |                                    |
| 12h00   | Clean Code: Exercice de Nommage avec [[Nommer avec le 3-Step-Model]]                                    | Exercice : RPN                                                   | Sparrow Deck                       |
| 12h30   | **üçï Repas üçΩÔ∏è**                                                                                        | **üçï Repas üçΩÔ∏è**                                                 | **üçï Repas üçΩÔ∏è**                   |
| 13h00   | **üçï Repas üçΩÔ∏è**                                                                                        | **üçï Repas üçΩÔ∏è**                                                 | **üçï Repas üçΩÔ∏è**                   |
| 13h30   | **üçï Repas üçΩÔ∏è**                                                                                        | **üçï Repas üçΩÔ∏è**                                                 | **üçï Repas üçΩÔ∏è**                   |
| 14h00   | Exercice: Mod√©liser == documenter                                                                       | Conception Logicielle; Couplage/Coh√©sion et organisation du code |                                    |
| 14h30   | Th√©orie : Primitive Obsession<br>+ Pattern "Value Object"<br>+ Pratique : Kata XXX                      | Architecture Hexagonale                                          |                                    |
| 15h00   | Th√©orie: Documenter vs. Commenter son code<br>Framework [[Di√°taxis]]<br>Git et les Conventional Commits | Exercice: Kata Birthday Greetings                                |                                    |
| 15h30   | Exercice: Mod√©liser == documenter                                                                       | ü´ß Clean Code vs IA ü§ñ                                           |                                    |
| 16h00   | Entretenir son code, mais pas uniquement (Tidying)                                                      | Off-Boarding sur la matrice de connaissance                      |                                    |
| 16h30   | Exercice: Tidying                                                                                       | R√©tro et Bilan                                                   |                                    |
| 17h00   | Bilan de la journ√©e                                                                                     | R√©tro et Bilan                                                   |                                    |
| 17h30   |                                                                                                         |                                                                  |                                    |
| 18h00   |                                                                                                         |                                                                  |                                    |
Autres trucs √† rajouter 
- [[Design Cards]]
- Collective Ownership
#### Brouillon

##### Me

lancement de la journ√©e avec une matrice des connaissances
=> Bien Identifier les connaissances qu'on va apporter sur les journ√©es 

th√©orie : le cycle de vie d'un logiciel
- O√π sont les specs ? O√π est la v√©rit√© ? O√π est la connaissance ?
pratique : code swap
th√©orie: c'est quoi le (clean) code
th√©orie: catalogue des principes
atelier: votre profil en conceptipon logicielle 

th√©orie (deep dive): Nommer les choses
atelier: 3StepModel

th√©orie (deep dive): Structurer le code == Structurer la connaissance
structurer un fichier de code
structurer / articuler plusireurs fichiers => conception
kata: Mod√©liser = Documenter (kataception : proposer un kata sur du tri de documention qui s'appuie sur Diataxis)

th√©orie: Conception Logicielle; Couplage/Coh√©sion et organisation du code
th√©orie: Architecture Hexagonale
pratique: kata birthday greetings

Th√©orie: SOLID & Design Patterns
pratique: kata RPN

##### Programme (Z)
###### L'imp√©ratif de qualit√© logicielle
- Cons√©quences d'une qualit√© insuffisante
- Le cycle infernal: √©criture, r√©√©criture
- Le concept de dette technique
- Outils et processus: n√©cessaires, mais pas suffisants
	- Outils de contr√¥le de qualit√©
	- Processus et formattage
	- Limitations
- Qu'est-ce que du code propre ?
###### Principes de conception propre
- Principes g√©n√©raux
	- Principes fondateurs de la POO
	- Les quatre principes de Kent Beck
	- Importance du nommage
	- Le bon sens par les acronymes: YAGNI/KISS/DRY/POLA
	- Quelques principes de programmation fonctionnelle
- Minimiser le couplage, maximiser la coh√©sion
	- Les principes SOLID
	- Coh√©sion et couplage
	- Stabilit√© et instabilit√©
- Supple design
	- Intention-Revealing Interfaces
	- Side-Effect-Free Functions
	- Defensive Programming
	- Conceptual Contours
	- Standalone Classes et Closure of Operations
	- Declarative Style of Design
	- Bonus: le principe de sym√©trie
###### Am√©liorer la qualit√© du code existant: smells et refactors
- Les concepts de smell et de refactor
- Les smells de Martin Fowler
	- Duplicated method
	- Duplicated class
	- Long method
	- Long class
	- Primitive obsession
	- Bref aper√ßu d'autres smells
- Uneffective Java
	- Egalit√©.. ou pas
	- Immutabilit√© √† trous
	- Obsolescence instantan√©e
	- Cachez cette exception que je ne saurais voir
	- ArrayList obsession
- Design faible
	- Modules techniques: Service-Dao-Entity
	- Generate getters and setters
	- La mort par imbrication: l'escalier du diable
	- Paquets d√©paquet√©s
	- Etre ou ne pas √™tre: la relation inappropri√©e Is-not-a
	- Javadoc et tests alibi
	- L'√©ditorialiste: l'intelligence enfouie dans les commentaires
	- La nuit des codes vivants
- Modifier proprement une application legacy
###### Panorama des autres m√©thodes de conception propre
- La conception Test-first au service de la qualit√©
- Software Craftsmanship
- Briques de conception standard
- Le domaine m√©tier comme noyau du logiciel: l'approche Domain-driven Design

# √Ä qui est destin√© cette formation ?

> **Public / Cible**  
> Caract√©ristiques : exp√©rience, formation, √¢ge, sexe, ‚Ä¶  
> Niveau actuel de comp√©tences ou de capacit√©s  
> Effectifs √† former  
> Composition √©ventuelle des groupes (par niveau / service / ‚Ä¶)

**üìå¬†D√©veloppeur-ses**
d√©sireux¬∑ses de s‚Äôam√©liorer, que ce soit sur leurs comp√©tences techniques, leur facult√©s √† s'exprimer au travers du code, ou a structurer leur connaissance au sein du logiciel

**üìå¬†Tech Leads ou üìå¬†Managers**
souhaitant s'approprier des pratiques de code, et apprendre √† les argumenter pour insuffler une dynamique d'am√©lioration de qualit√© √† leurs √©quipes

**üìå¬†Architectes**
voulant rendre sa dimension collective, au code, sa conception et son architecture logicielle

**üìå¬†Managers**
souhaitant insuffler une dynamique d'am√©lioration continue √† leurs √©quipes


_\<Lister les personae>_
# Pr√©requis

> (pr√©ciser si souhait√© et/ou obligatoire)
> Connaissance d'un logiciel, installation en amont de la formation, cr√©ation de compte‚Ä¶

## Comp√©tences requises

_\<Connaissances pr√©alables n√©cessaires pour la formation>_
_\<Ressources √† avoir consult√© au pr√©alables de la formation>_

Aucune connaissance technique n‚Äôest requise. Les exemples seront principalement fournis en langage orient√© object (pour les personnes ayant un background dans un autre langage, nous consulter).

## Mat√©riel requis

_\<Pr√©requis mat√©riel et/ou logiciels>_

Vous devez avoir un poste de travail avec un environnement de d√©veloppement (si besoin, nous consulter)  
Pour les personnes connaissant Java, l‚ÄôIDE IntelliJ est recommand√©, pour celles connaissant C#, Visual Studio avec Resharper ou Rider

# Evaluation

> **Indicateurs de r√©sultat**  
> D√©finir pr√©cis√©ment le r√©sultat attendu, les crit√®res de mesure, et le niveau de performance, sachant que la formation n√©cessite une certaine pratique pour l‚Äôatteindre (indicateurs quantitatifs : quantit√©s, effectifs, taux, d√©lais)

- Evaluation initiale sur les attentes et difficult√©s
- QCM / Revues actives
- Retours d‚Äôexp√©rience collectifs
- Evaluation de satisfaction post formation

Z 
- L'√©valuation des acquis de la formation se fera en s√©ance au travers d'ateliers, d'exercices et/ou de travaux pratiques. Dans le cas d'une formation officielle √©diteur, veuillez nous consulter afin que nous vous fassions part des modalit√©s d'√©valuation.
- A l'issue de la formation, vous sera transmis une √©valuation √† chaud de l'action de formation qui vous permettra de nous faire part de vos retours quant √† votre exp√©rience apprenant avec Zenika

Octo
- L'√©valuation des acquis se fait tout au long de la session au travers des ateliers et des mises en pratique.
- Afin de valider les comp√©tences acquises lors de la formation, un formulaire d'auto-positionnement est envoy√© en amont et en aval de celle-ci.
- En l'absence de r√©ponse d'un ou plusieurs participants, un temps sera consacr√© en ouverture de session pour prendre connaissance du positionnement de chaque stagiaire sur les objectifs p√©dagogiques √©valu√©s.
- Une √©valuation √† chaud est √©galement effectu√©e en fin de session pour mesurer la satisfaction des stagiaires et un certificat de r√©alisation leur est adress√© individuellement.

# Id√©ation
## Nuage de mots

CleanCode
Nommage
Exercice de nommage
Le plus grand mensonge
Mod√©lisation
Couplage
Coh√©sion
Complexit√©
Dette technique
Co√ªt du logiciel
Changement
SLAP
Demeter
SOLID
CUPID
Commentaires
Documentation
Living Documentation
Di√°taxis
Git
Conventional Commits
Tests
Tests unitaires
Conception logicielle
Design Patterns
On Boarding
Off Boarding
Matrice de connaissance
Connaissance
Domain
Mod√®le mental partage
Knowledge Worker
Veille
Chunk
Innovation
Partage
Apprendre
Pair-Programming
Mob-Programming
Architecture d√©coupl√©e
[[Architecture Hexagonale]]
Clean Architecture

## Pistes

> https://trello.com/c/5dTWfha2/13-formation-clean-code


D√©roul√©

OnBoarding
Introduction : qu'est ce que la conception logicielle ?
CleanCode : comprendre le code
	Naming
	Mod√©lisation
	Coh√©sion
Dette technique et complexit√© logicielle
	Complexit√© obligatoire, fonctionnelle et Complexit√© accidentelle
	O√π trouver la connaissance manquante ?
Documentation
	Les commentaires
	Aller plus loin avec Git
Clean Code : s'exprimer
	SOLID
	Les design Patterns
Architecture logicielles
	Clean Architecture
	Couplage
Couplage vs Cohesion
Refactoring vs Tidying


## En tant que d√©veloppeur,  
A l'issue de la formation, je suis capable d'appliquer le Clean Code au quotidien  
Afin de rendre le code sur lequel je travaille, compr√©hensible et accessible √† tous mes successeurs

_Objectifs p√©dagogiques de la formation :_
- Je suis capable d'√™tre critique sur le code produit
- Je suis capable de suivre des Guidelines de d√©veloppement
	- Naming, Indentation
	- KISS, DRY
	- SOLID

_Objectif du ticket :_
- Mettre √† disposition une fiche de synth√®se de la formation (Titre, description, format de la formation, et dur√©e)
- Mettre √† disposition un support de formation, √† destination des stagiaires (les gens form√©s), qui sera d√©roul√© au cours de la formation
- Mettre √† disposition le d√©roul√© de formation, √† destination des formateurs, avec
- Identifier les formateurs capables de dispenser la formation
- S'assurer que le d√©roul√© de la formation r√©ponde bien aux objectifs p√©dagogiques list√©s ci-dessus (un stagiaire qui a suivit la formation, est capable de r√©ponde "oui je sais le faire" √† toutes les phrases ci-dessus)

# üîóRessources
## Comparer avec d'autres formations du march√©
- https://training.zenika.com/fr/training/clean-code/description
	- https://platon.zenika.com/api/public/trainings/doc/clean-code.pdf?language=FR
- https://www.humancoders.com/formations/software-craftsmanship-tdd-clean-code