---
ressource:
  - ğŸ“ Formation
titre: "Conception logicielle avancÃ©e : Clean & Tidy Code"
âŒ› durÃ©e: ğŸ—“ï¸ 2j
ğŸ§‘â€ğŸ« format:
  - PrÃ©sentiel
ğŸ“ pÃ©dagogie: 30% thÃ©orique, 70% pratique
ğŸ‘¥ Participants: "8"
Inter (HT/pers): 
Intra (HT): 
ğŸ“š thÃ©matiques:
---

# Format

Sur un format prÃ©sentiel pour vivre les ateliers qui seront dÃ©roulÃ©s.
# Description

Le logiciel d'aujourd'hui rÃ©pond aux besoin de l'instant, mais ce n'est pas suffisant quand on dÃ©veloppe un produit de qualitÃ©. Un bon produit est conforme dans le temps, maintenable Ã  moindre frais, et permet de dÃ©velopper de nouvelles fonctionnalitÃ©s vite et bien.

Le Clean Code est un ensemble de pratiques contribuant Ã  rendre cela possible, en permettant aux Ã©quipes de collaborer efficacement en asynchrone et dans le temps et en leur permettant de fluidifier les interactions entre les humains et le code.

Cette formation vous propose de vous approprier un ensemble de principes, de pratiques et de techniques qui amÃ©lioreront votre approche du Clean Code, mais aussi des exercices pour comprendre vos prÃ©fÃ©rences en terme de conception logicielle. Cela vous permettra d'appliquer l'ensemble de ces Ã©lÃ©ments Ã  un cadre oÃ¹ vous verrez les avantages de modÃ©liser judicieusement votre code.

#### Brouillon

> Le Domain Driven Design (DDD) permet de modÃ©liser efficacement les besoins mÃ©tier afin de mieux gÃ©rer la complexitÃ© des logiciels. Traditionnellement associÃ© Ã  la Programmation OrientÃ©e Objet, les patterns tactiques du DDD peuvent toutefois Ãªtre adaptÃ©es pour utiliser cette approche avec la Programmation Fonctionnelle.
>
> La Programmation Fonctionnelle est un paradigme qui favorise des techniques comme l'immutabilitÃ©, les fonctions pures et la composition fonctionnelle pour crÃ©er un code plus prÃ©visible et maintenable.
>
> Le langage TypeScript est Ã  cheval entre les approches objets et fonctionnelles, et prÃ©sente des particularitÃ©s qui peuvent rendre difficile lâ€™adoption du DDD selon lâ€™un de ces deux paradigmes.
>
> Cette formation vous propose de dÃ©couvrir des approches adaptÃ©es spÃ©cifiquement Ã  TypeScript qui intÃ¨grent les avantages de la programmation fonctionnelle avec la structuration de donnÃ©es sous forme dâ€™objets dans un cadre DDD. Vous apprendrez comment implÃ©menter des modÃ¨les mÃ©tier efficacement et en restant pragmatique sur lâ€™utilisation du paradigme fonctionnel pour crÃ©er des logiciels robustes et maintenables.

>==WIP 
> Le logiciel d'aujourd'hui rÃ©pond aux besoin de l'instant, mais ce n'est pas suffisant quand on dÃ©veloppe un produit de qualitÃ©. Un bon produit est conforme dans le temps, maintenable Ã  moindre frais, et permet de dÃ©velopper de nouvelles fonctionnalitÃ©s vite et bien.
> 
> Le Clean Code est un ensemble de pratiques contribuant Ã  rendre cela possible, en permettant aux Ã©quipes de collaborer efficacement en asynchrone et dans le temps et en leur permettant de fluidifier les interactions entre les humains et le code.
> 
> Cette formation vous propose de vous approprier un ensemble de principes et de pratiques qui amÃ©lioreront votre approche du Clean Code,  des exercices pour comprendre votre prÃ©fÃ©rences en terme de conception logicielle, et d'appliquer l'ensemble de ces Ã©lÃ©ments Ã  un cadre oÃ¹ vous verrez les avantages de modÃ©liser judicieusement vote code.
>
> Un logiciel est un outil permettant de rÃ©pondre Ã  un besoin rÃ©el
> DÃ©velopper un logiciel intervient pour rÃ©pondre Ã  un besoin mÃ©tier
> C'est une activitÃ© d'Ã©quipe
> Collaborer efficacement 
> "Une bonne conception et une excellence techniuq renforce l'agilitÃ©"
> 
> A l'issue de cette formation, vous serez en mesure de vous poser des questions permettant de structurer vos logiciels, et vous aurez des Ã©lÃ©ments et des arguments de rÃ©ponses diffÃ©rentes en fonction des contextes mÃ©tiers que vous rencontrerez.
> 
> Vous trouverez ces Ã©lÃ©ments de comprÃ©hension au travers de votre comprÃ©hension du Clean Code, votre approche des Design Patterns et quelques patterns classiques d'architecture logicielle.
> 
> Vous approfondirez des pratiques d'entretiens de votre parc applicatif
> ==


> La pÃ©rennitÃ© dâ€™une base de code repose sur la qualitÃ© de son Ã©criture et sur la maÃ®trise du niveau de sa dette technique. La bonne connaissance des principes SOLID permet de percevoir les non-qualitÃ©s dans les bases de code existantes et de comprendre les rÃ¨gles du Clean Code. Cette comprÃ©hension permet de sÃ©curiser et de garantir le succÃ¨s de lâ€™Ã©tape de refactoring, objet de cette formation.

> Z: 
> L'introduction des mÃ©thodes agiles a permis de mieux construire des logiciels conformes aux besoins rÃ©els, et d'amÃ©liorer le processus de delivery. Le clean code est un ensemble complÃ©mentaire de pratiques techniques, permettant d'assurer la pÃ©rennitÃ© du logiciel construit. Un code propre est en effet la condition sine qua non d'un logiciel robuste (coÃ»t de maintenance limitÃ©) et Ã©volutif (pouvant Ãªtre adaptÃ© aux nouveaux besoins).

> O:
> Les artisans du logiciel savent que la qualitÃ© du code va de pair avec la rapiditÃ©, la simplicitÃ© et l'efficacitÃ© du dÃ©veloppement. Les pratiques, principes et standards qui dÃ©finissent cette qualitÃ© sont rassemblÃ©es sous le vocable Â« Clean Code Â». Ils permettent Ã  toute Ã©quipe de crÃ©er, de maintenir (ou de rÃ©tablir) un code de grande qualitÃ©, et concernent de multiples aspects de la programmation : conventions de style, rÃ¨gles de nommage, critÃ¨res de qualitÃ© des fonctions, des classes, des relations entre les classes.

Ã€ l'issue de cette formation, vous pourrez mettre en Å“uvre les pratiques de base permettant d'obtenir un code de grande qualitÃ©, testÃ© et flexible..
# Objectifs

- **Comprendre les principes fondamentaux du Clean Code
	- ÃŠtre capable de dÃ©finir et d'expliquer les concepts clÃ©s et les enjeux du Clean Code
	- Savoir appliquer ces principes dans un cadre de travail simple
	- ÃŠtre capable se positionner et d'argumenter face Ã  des principes moins consensuels
- **ConnaÃ®tre et reconnaÃ®tre des structures courantes dans le code**
	- ÃŠtre capable d'identifier des anti-patterns
	- ÃŠtre capable d'identifier des design patterns
	- Savoir s'appuyer sur des principes avancÃ©s de conception logicielle pour structurer son code (principes SOLID, Couplage et CohÃ©sion)
- ConnaÃ®tre et savoir appliquer les techniques d'amÃ©lioration du code (Tidyings et Refactorings) sur du code un peu complexe

#### Brouillon

> **CompÃ©tences cibles**

Mettre en Ã©vidence les connaissances critiques dans le logiciel
Construire une carte mentale permettant de retrouver ce que l'on cherche dans le logiciel
Ecrire du code pour les humains
Ecrire du code facile Ã  prendre en main

> **Objectif de la Formation**  
> Ce que le stagiaire devra savoir faire Ã  la fin de la formation, de maniÃ¨re observable  
> Ce quâ€™il devra pouvoir connaÃ®tre ou comprendre  
> Utiliser des verbes dont le sujet est Â« le stagiaire Â» et non le formateur  
> DÃ©finir les conditions :  
> Situations courantes / situations exceptionnelles  
> Ã‰chÃ©ances, urgences, â€¦

_<Ce que les personnes formÃ©es seront faire Ã  la fin de la formation>_

- Mettre en Ã©vidence les connaissances critiques dans le logiciel
- Construire une carte mentale permettant de retrouver ce que l'on cherche dans le logiciel
- Ecrire du code pour les humains
- Ecrire du code facile Ã  prendre en main

- **Comprendre les principes fondamentaux du Clean Code
	- ÃŠtre capable de dÃ©finir et d'expliquer les concepts clÃ©s et les enjeux du Clean Code
	- Savoir appliquer ces principes dans un cadre de travail simple
	- ÃŠtre capable se positionner et d'argumenter face Ã  des principes moins consensuels
- **ConnaÃ®tre et reconnaÃ®tre des structures courantes dans le code**
	- ÃŠtre capable d'identifier des anti-patterns
	- ÃŠtre capable d'identifier des design patterns
	- Savoir s'appuyer sur des principes avancÃ©s de conception logicielle pour structurer son code (principes SOLID, Couplage et CohÃ©sion)
- ConnaÃ®tre et savoir appliquer les techniques d'amÃ©lioration du code (Tidyings et Refactorings) sur du code un peu complexe

Comprendre / ConnaÃ®tre / maitreiser

- **Comprendre les principes fondamentaux du Clean Code
	- ÃŠtre capable de dÃ©finir et d'expliquer les concepts clÃ©s et les enjeux du Clean Code
	- Savoir appliquer ces principes dans un cadre de travail simple
	- ÃŠtre capable se positionner et d'argumenter face Ã  des principes moins consensuels
- **ConnaÃ®tre et reconnaÃ®tre des structures courantes dans le code**
	- ÃŠtre capable d'identifier des anti-patterns
	- ÃŠtre capable d'identifier des design patterns
	- Savoir s'appuyer sur des principes avancÃ©s de conception logicielle pour structurer son code (principes SOLID, Couplage et CohÃ©sion)
- ConnaÃ®tre et savoir appliquer les techniques d'amÃ©lioration du code (Tidyings et Refactorings) sur du code un peu complexe

- **Comprendre les principes fondamentaux du Clean Code:** DÃ©finir et expliquer les concepts clÃ©s du Clean Code, tels que la lisibilitÃ©, la maintenabilitÃ©, la testabilitÃ© et la rÃ©utilisabilitÃ©.
- **Identifier les mauvaises pratiques courantes:** ReconnaÃ®tre les anti-patterns courants en programmation qui nuisent Ã  la qualitÃ© du code.
  => ==ConnaÃ®tre une grille de lecture du code pour savoir reconnaitre patterns et anti patterns==
- **Appliquer les principes SOLID:** MaÃ®triser les principes SOLID (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) pour concevoir des classes et des modules bien structurÃ©s.
- **RÃ©diger du code propre et expressif:** Utiliser des noms de variables, de fonctions et de classes significatifs, un formatage cohÃ©rent et des commentaires pertinents.
- **MaÃ®triser les techniques de refactoring:** Appliquer des techniques de refactoring pour amÃ©liorer la structure et la lisibilitÃ© du code existant sans en modifier le comportement.

>Z:
> - Approfondir les principes de programmation orientÃ©e objet pour Ã©crire du code conforme Ã  l'Ã©tat de l'art
> - ConcrÃ©tiser et mettre en pratique ces principes avec des exemples simples et frappants
> - Mettre sous contrÃ´le la dette technique par le refactoring
> - Apprendre les techniques spÃ©cifiques aux applications legacy
> - AcquÃ©rir une vision synthÃ©tique des mÃ©thodes de conception propre les plus utilisÃ©es

> IB Formations
> - Comprendre la notion de dette technique et les principes SOLID
> - ConnaÃ®tre les enjeux de lâ€™Ã©criture de tests automatisÃ©s et le coÃ»t de la mise en production de code non testÃ© automatiquement
> - MaÃ®triser lâ€™Ã©criture de tests automatisÃ©s, unitaires et tests dâ€™intÃ©gration ainsi que les principes et patterns du "clean code" en programmation objet
> - Comprendre le principe du travail Ã  partir de katas et les pratiques de lâ€™eXtreme programming : pair programming, coding dojos
> - Savoir appliquer ces principes et patterns au dÃ©veloppement de nouveau code (greenfield development) et au code existant (brownfield development)

>O: 
> - Identifier, expliquer et illustrer les principaux Ã©lÃ©ments qui forment le Â« Clean Code Â»
> - Savoir utiliser ces standards sur un projet exemple, ainsi que sur du code existant
> - DÃ©finir le lien entre la qualitÃ© du code et la facilitÃ© d'Ã©volution des applications

# Programme

_\<Programme grosse maille de la formation ou lien vers le plan de cours>_
_\<Cette section permet Ã©galement de dÃ©tailler et travailler les diffÃ©rents modules de la formation>_

| Horaire | Jour 1                                                                                                  | Jour 2                                                           | Jour 3 ?                           |
| ------- | ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | ---------------------------------- |
| 9h00    | ğŸ‘‹ Accueil <br>& Petit dÃ©jeuner ğŸ¥                                                                      | ğŸ‘‹ Accueil <br>& Petit dÃ©jeuner ğŸ¥                               | ğŸ‘‹ Accueil <br>& Petit dÃ©jeuner ğŸ¥ |
| 9h30    | Lancement de la journÃ©e<br>"le Clean Code n'existe pas"                                                 | ThÃ©orie: SOLID & Design Patterns                                 |                                    |
| 10h00   | Atelier : On-boarding avec une matrice de connaissance                                                  | Exercice : RPN                                                   |                                    |
| 10h30   |                                                                                                         | Exercice : RPN                                                   |                                    |
| 11h00   | Clean Code : ThÃ©orie                                                                                    | ThÃ©orie: SOLID & Design Patterns                                 |                                    |
| 11h30   | Clean Code : ThÃ©orie                                                                                    | Exercice : RPN                                                   |                                    |
| 12h00   | Clean Code: Exercice de Nommage avec [[Nommer avec le 3-Step-Model]]                                    | Exercice : RPN                                                   | Sparrow Deck                       |
| 12h30   | **ğŸ• Repas ğŸ½ï¸**                                                                                        | **ğŸ• Repas ğŸ½ï¸**                                                 | **ğŸ• Repas ğŸ½ï¸**                   |
| 13h00   | **ğŸ• Repas ğŸ½ï¸**                                                                                        | **ğŸ• Repas ğŸ½ï¸**                                                 | **ğŸ• Repas ğŸ½ï¸**                   |
| 13h30   | **ğŸ• Repas ğŸ½ï¸**                                                                                        | **ğŸ• Repas ğŸ½ï¸**                                                 | **ğŸ• Repas ğŸ½ï¸**                   |
| 14h00   | Exercice: ModÃ©liser == documenter                                                                       | Conception Logicielle; Couplage/CohÃ©sion et organisation du code |                                    |
| 14h30   | ThÃ©orie : Primitive Obsession<br>+ Pattern "Value Object"<br>+ Pratique : Kata XXX                      | Architecture Hexagonale                                          |                                    |
| 15h00   | ThÃ©orie: Documenter vs. Commenter son code<br>Framework [[DiÃ¡taxis]]<br>Git et les Conventional Commits | Exercice: Kata Birthday Greetings                                |                                    |
| 15h30   | Exercice: ModÃ©liser == documenter                                                                       | ğŸ«§ Clean Code vs IA ğŸ¤–                                           |                                    |
| 16h00   | Entretenir son code, mais pas uniquement (Tidying)                                                      | Off-Boarding sur la matrice de connaissance                      |                                    |
| 16h30   | Exercice: Tidying                                                                                       | RÃ©tro et Bilan                                                   |                                    |
| 17h00   | Bilan de la journÃ©e                                                                                     | RÃ©tro et Bilan                                                   |                                    |
| 17h30   |                                                                                                         |                                                                  |                                    |
| 18h00   |                                                                                                         |                                                                  |                                    |
Autres trucs Ã  rajouter 
- [[Design Cards]]
- Collective Ownership
#### Brouillon

##### Me

lancement de la journÃ©e avec une matrice des connaissances
=> Bien Identifier les connaissances qu'on va apporter sur les journÃ©es 

thÃ©orie : le cycle de vie d'un logiciel
- OÃ¹ sont les specs ? OÃ¹ est la vÃ©ritÃ© ? OÃ¹ est la connaissance ?
pratique : code swap
thÃ©orie: c'est quoi le (clean) code
thÃ©orie: catalogue des principes
atelier: votre profil en conceptipon logicielle 

thÃ©orie (deep dive): Nommer les choses
atelier: 3StepModel

thÃ©orie (deep dive): Structurer le code == Structurer la connaissance
structurer un fichier de code
structurer / articuler plusireurs fichiers => conception
kata: ModÃ©liser = Documenter (kataception : proposer un kata sur du tri de documention qui s'appuie sur Diataxis)

thÃ©orie: Conception Logicielle; Couplage/CohÃ©sion et organisation du code
thÃ©orie: Architecture Hexagonale
pratique: kata birthday greetings

ThÃ©orie: SOLID & Design Patterns
pratique: kata RPN

##### Programme (Z)
###### L'impÃ©ratif de qualitÃ© logicielle
- ConsÃ©quences d'une qualitÃ© insuffisante
- Le cycle infernal: Ã©criture, rÃ©Ã©criture
- Le concept de dette technique
- Outils et processus: nÃ©cessaires, mais pas suffisants
	- Outils de contrÃ´le de qualitÃ©
	- Processus et formattage
	- Limitations
- Qu'est-ce que du code propre ?
###### Principes de conception propre
- Principes gÃ©nÃ©raux
	- Principes fondateurs de la POO
	- Les quatre principes de Kent Beck
	- Importance du nommage
	- Le bon sens par les acronymes: YAGNI/KISS/DRY/POLA
	- Quelques principes de programmation fonctionnelle
- Minimiser le couplage, maximiser la cohÃ©sion
	- Les principes SOLID
	- CohÃ©sion et couplage
	- StabilitÃ© et instabilitÃ©
- Supple design
	- Intention-Revealing Interfaces
	- Side-Effect-Free Functions
	- Defensive Programming
	- Conceptual Contours
	- Standalone Classes et Closure of Operations
	- Declarative Style of Design
	- Bonus: le principe de symÃ©trie
###### AmÃ©liorer la qualitÃ© du code existant: smells et refactors
- Les concepts de smell et de refactor
- Les smells de Martin Fowler
	- Duplicated method
	- Duplicated class
	- Long method
	- Long class
	- Primitive obsession
	- Bref aperÃ§u d'autres smells
- Uneffective Java
	- EgalitÃ©.. ou pas
	- ImmutabilitÃ© Ã  trous
	- Obsolescence instantanÃ©e
	- Cachez cette exception que je ne saurais voir
	- ArrayList obsession
- Design faible
	- Modules techniques: Service-Dao-Entity
	- Generate getters and setters
	- La mort par imbrication: l'escalier du diable
	- Paquets dÃ©paquetÃ©s
	- Etre ou ne pas Ãªtre: la relation inappropriÃ©e Is-not-a
	- Javadoc et tests alibi
	- L'Ã©ditorialiste: l'intelligence enfouie dans les commentaires
	- La nuit des codes vivants
- Modifier proprement une application legacy
###### Panorama des autres mÃ©thodes de conception propre
- La conception Test-first au service de la qualitÃ©
- Software Craftsmanship
- Briques de conception standard
- Le domaine mÃ©tier comme noyau du logiciel: l'approche Domain-driven Design

# Ã€ qui est destinÃ© cette formation ?

> **Public / Cible**  
> CaractÃ©ristiques : expÃ©rience, formation, Ã¢ge, sexe, â€¦  
> Niveau actuel de compÃ©tences ou de capacitÃ©s  
> Effectifs Ã  former  
> Composition Ã©ventuelle des groupes (par niveau / service / â€¦)

**ğŸ“ŒÂ DÃ©veloppeur-ses**
dÃ©sireuxÂ·ses de sâ€™amÃ©liorer, que ce soit sur leurs compÃ©tences techniques, leur facultÃ©s Ã  s'exprimer au travers du code, ou a structurer leur connaissance au sein du logiciel

**ğŸ“ŒÂ Tech Leads ou ğŸ“ŒÂ Managers**
souhaitant s'approprier des pratiques de code, et apprendre Ã  les argumenter pour insuffler une dynamique d'amÃ©lioration de qualitÃ© Ã  leurs Ã©quipes

**ğŸ“ŒÂ Architectes**
voulant rendre sa dimension collective, au code, sa conception et son architecture logicielle

**ğŸ“ŒÂ Managers**
souhaitant insuffler une dynamique d'amÃ©lioration continue Ã  leurs Ã©quipes


_\<Lister les personae>_
# PrÃ©requis

> (prÃ©ciser si souhaitÃ© et/ou obligatoire)
> Connaissance d'un logiciel, installation en amont de la formation, crÃ©ation de compteâ€¦

## CompÃ©tences requises

_\<Connaissances prÃ©alables nÃ©cessaires pour la formation>_
_\<Ressources Ã  avoir consultÃ© au prÃ©alables de la formation>_

Aucune connaissance technique nâ€™est requise. Les exemples seront principalement fournis en langage orientÃ© object (pour les personnes ayant un background dans un autre langage, nous consulter).

## MatÃ©riel requis

_\<PrÃ©requis matÃ©riel et/ou logiciels>_

Vous devez avoir un poste de travail avec un environnement de dÃ©veloppement (si besoin, nous consulter)  
Pour les personnes connaissant Java, lâ€™IDE IntelliJ est recommandÃ©, pour celles connaissant C#, Visual Studio avec Resharper ou Rider

# Evaluation

> **Indicateurs de rÃ©sultat**  
> DÃ©finir prÃ©cisÃ©ment le rÃ©sultat attendu, les critÃ¨res de mesure, et le niveau de performance, sachant que la formation nÃ©cessite une certaine pratique pour lâ€™atteindre (indicateurs quantitatifs : quantitÃ©s, effectifs, taux, dÃ©lais)

- Evaluation initiale sur les attentes et difficultÃ©s
- QCM / Revues actives
- Retours dâ€™expÃ©rience collectifs
- Evaluation de satisfaction post formation

Z 
- L'Ã©valuation des acquis de la formation se fera en sÃ©ance au travers d'ateliers, d'exercices et/ou de travaux pratiques. Dans le cas d'une formation officielle Ã©diteur, veuillez nous consulter afin que nous vous fassions part des modalitÃ©s d'Ã©valuation.
- A l'issue de la formation, vous sera transmis une Ã©valuation Ã  chaud de l'action de formation qui vous permettra de nous faire part de vos retours quant Ã  votre expÃ©rience apprenant avec Zenika

Octo
- L'Ã©valuation des acquis se fait tout au long de la session au travers des ateliers et des mises en pratique.
- Afin de valider les compÃ©tences acquises lors de la formation, un formulaire d'auto-positionnement est envoyÃ© en amont et en aval de celle-ci.
- En l'absence de rÃ©ponse d'un ou plusieurs participants, un temps sera consacrÃ© en ouverture de session pour prendre connaissance du positionnement de chaque stagiaire sur les objectifs pÃ©dagogiques Ã©valuÃ©s.
- Une Ã©valuation Ã  chaud est Ã©galement effectuÃ©e en fin de session pour mesurer la satisfaction des stagiaires et un certificat de rÃ©alisation leur est adressÃ© individuellement.

# IdÃ©ation
## Nuage de mots

CleanCode
Nommage
Exercice de nommage
Le plus grand mensonge
ModÃ©lisation
Couplage
CohÃ©sion
ComplexitÃ©
Dette technique
CoÃ»t du logiciel
Changement
SLAP
Demeter
SOLID
CUPID
Commentaires
Documentation
Living Documentation
DiÃ¡taxis
Git
Conventional Commits
Tests
Tests unitaires
Conception logicielle
Design Patterns
On Boarding
Off Boarding
Matrice de connaissance
Connaissance
Domain
ModÃ¨le mental partage
Knowledge Worker
Veille
Chunk
Innovation
Partage
Apprendre
Pair-Programming
Mob-Programming
Architecture dÃ©couplÃ©e
[[Architecture Hexagonale]]
Clean Architecture

## Pistes

> https://trello.com/c/5dTWfha2/13-formation-clean-code


DÃ©roulÃ©

OnBoarding
Introduction : qu'est ce que la conception logicielle ?
CleanCode : comprendre le code
	Naming
	ModÃ©lisation
	CohÃ©sion
Dette technique et complexitÃ© logicielle
	ComplexitÃ© obligatoire, fonctionnelle et ComplexitÃ© accidentelle
	OÃ¹ trouver la connaissance manquante ?
Documentation
	Les commentaires
	Aller plus loin avec Git
Clean Code : s'exprimer
	SOLID
	Les design Patterns
Architecture logicielles
	Clean Architecture
	Couplage
Couplage vs Cohesion
Refactoring vs Tidying


## En tant que dÃ©veloppeur,  
A l'issue de la formation, je suis capable d'appliquer le Clean Code au quotidien  
Afin de rendre le code sur lequel je travaille, comprÃ©hensible et accessible Ã  tous mes successeurs

_Objectifs pÃ©dagogiques de la formation :_
- Je suis capable d'Ãªtre critique sur le code produit
- Je suis capable de suivre des Guidelines de dÃ©veloppement
	- Naming, Indentation
	- KISS, DRY
	- SOLID

_Objectif du ticket :_
- Mettre Ã  disposition une fiche de synthÃ¨se de la formation (Titre, description, format de la formation, et durÃ©e)
- Mettre Ã  disposition un support de formation, Ã  destination des stagiaires (les gens formÃ©s), qui sera dÃ©roulÃ© au cours de la formation
- Mettre Ã  disposition le dÃ©roulÃ© de formation, Ã  destination des formateurs, avec
- Identifier les formateurs capables de dispenser la formation
- S'assurer que le dÃ©roulÃ© de la formation rÃ©ponde bien aux objectifs pÃ©dagogiques listÃ©s ci-dessus (un stagiaire qui a suivit la formation, est capable de rÃ©ponde "oui je sais le faire" Ã  toutes les phrases ci-dessus)

# ğŸ”—Ressources
## Comparer avec d'autres formations du marchÃ©
- https://training.zenika.com/fr/training/clean-code/description
	- https://platon.zenika.com/api/public/trainings/doc/clean-code.pdf?language=FR
- https://www.humancoders.com/formations/software-craftsmanship-tdd-clean-code